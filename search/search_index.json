{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started # Starting with Toned is very straightforward. It is expected that you have knowledge of Fusion as Toned is essentially an extension of Fusion. Installation # With Wally Under Wally's dependencies add Toned = \"astrealrblx/toned@0.1.3\" Use wally install to install the dependency to your packages directory In Roblox Go to Toned's releases and download the latest one Place the file in ReplicatedStorage You're now ready to start using Toned! Head over to the StyleSheet page to learn how to create your first style sheet and apply it.","title":"Getting Started"},{"location":"#getting-started","text":"Starting with Toned is very straightforward. It is expected that you have knowledge of Fusion as Toned is essentially an extension of Fusion.","title":"Getting Started"},{"location":"#installation","text":"With Wally Under Wally's dependencies add Toned = \"astrealrblx/toned@0.1.3\" Use wally install to install the dependency to your packages directory In Roblox Go to Toned's releases and download the latest one Place the file in ReplicatedStorage You're now ready to start using Toned! Head over to the StyleSheet page to learn how to create your first style sheet and apply it.","title":"Installation"},{"location":"attribute/","text":"Attribute # Attribute is a powerful SpecialKey that ships with Toned. You can use it to easily apply certain styles to specific instances. Applying Attributes # New 'ScreenGui' { [ Toned . StyleSheet ] = [[ .TextLabel { BackgroundColor3: #212121; TextColor3: #FFFFFF; Size: [0.8, 0, 0.1, 0]; Position: [0.1, 0, 0.1, 0]; } %RedBackground { BackgroundColor3: [255, 0, 0]; } ]] , [ Children ] = { New 'TextLabel' { Text = 'Hello World!' , [ Toned . Attribute ] = 'RedBackground' , }, } } In the above example, we use Attribute on the TextLabel and set it to RedBackground . What this does is it sets an internal Roblox attribute on the instance which the style sheet then looks for when we being applied. We extract that attribute and determine if a selector uses it and if it does then apply the style. An instance can have multiple attributes too. To do this you provide the Attribute key a table of strings instead of a single string. New 'ScreenGui' { [ Toned . StyleSheet ] = [[ .TextLabel { BackgroundColor3: #212121; TextColor3: #FFFFFF; Size: [0.8, 0, 0.1, 0]; Position: [0.1, 0, 0.1, 0]; } %RedBackground { BackgroundColor3: [255, 0, 0]; } %BlueText { TextColor3: [0, 0, 255]; } ]] , [ Children ] = { New 'TextLabel' { Text = 'Hello World!' , [ Toned . Attribute ] = { 'RedBackground' , 'BlueText' }, }, } }","title":"Attribute"},{"location":"attribute/#attribute","text":"Attribute is a powerful SpecialKey that ships with Toned. You can use it to easily apply certain styles to specific instances.","title":"Attribute"},{"location":"attribute/#applying-attributes","text":"New 'ScreenGui' { [ Toned . StyleSheet ] = [[ .TextLabel { BackgroundColor3: #212121; TextColor3: #FFFFFF; Size: [0.8, 0, 0.1, 0]; Position: [0.1, 0, 0.1, 0]; } %RedBackground { BackgroundColor3: [255, 0, 0]; } ]] , [ Children ] = { New 'TextLabel' { Text = 'Hello World!' , [ Toned . Attribute ] = 'RedBackground' , }, } } In the above example, we use Attribute on the TextLabel and set it to RedBackground . What this does is it sets an internal Roblox attribute on the instance which the style sheet then looks for when we being applied. We extract that attribute and determine if a selector uses it and if it does then apply the style. An instance can have multiple attributes too. To do this you provide the Attribute key a table of strings instead of a single string. New 'ScreenGui' { [ Toned . StyleSheet ] = [[ .TextLabel { BackgroundColor3: #212121; TextColor3: #FFFFFF; Size: [0.8, 0, 0.1, 0]; Position: [0.1, 0, 0.1, 0]; } %RedBackground { BackgroundColor3: [255, 0, 0]; } %BlueText { TextColor3: [0, 0, 255]; } ]] , [ Children ] = { New 'TextLabel' { Text = 'Hello World!' , [ Toned . Attribute ] = { 'RedBackground' , 'BlueText' }, }, } }","title":"Applying Attributes"},{"location":"ignore/","text":"Ignore # With the current way Fusion handles SpecialKeys, style sheets are applied after the properties you specifically define for an instance. What this means is style sheets will override any properties you set. This is usually not the behavior that is expected, however, there currently is no easy workaround to this problem. As a fix, albeit not the best, Toned introduces the Ignore key. Ignoring Properties # Let's look at an example that showcases how to use the key. New 'ScreenGui' { [ Toned . StyleSheet ] = [[ .TextLabel { BackgroundColor3: #212121; TextColor3: #FFFFFF; Size: [0.8, 0, 0.1, 0]; Position: [0.1, 0, 0.1, 0]; Text: \"Hello World!\"; } ]] , [ Children ] = { New 'TextLabel' { Text = 'Goodbye World!' , [ Toned . Ignore ] = { 'Text' } } } } Notice how in our style sheet we actually set the Text property of TextLabels to be Hello World! . When we create a child text label you would expect that Goodbye World! would override the style sheet's Text property. Unfortunately, this isn't the case. To work around this we use the Ignore key and set it to a table of values. In our case we only want one value, Text . Now we'll actually see Goodbye World! like intended. This is an unfortunate byproduct of Fusion's internal SpecialKey system not supporting a system like style sheets. While it can sometimes be tedious to set, the Ignore key is the best solution for this as of right now.","title":"Ignore"},{"location":"ignore/#ignore","text":"With the current way Fusion handles SpecialKeys, style sheets are applied after the properties you specifically define for an instance. What this means is style sheets will override any properties you set. This is usually not the behavior that is expected, however, there currently is no easy workaround to this problem. As a fix, albeit not the best, Toned introduces the Ignore key.","title":"Ignore"},{"location":"ignore/#ignoring-properties","text":"Let's look at an example that showcases how to use the key. New 'ScreenGui' { [ Toned . StyleSheet ] = [[ .TextLabel { BackgroundColor3: #212121; TextColor3: #FFFFFF; Size: [0.8, 0, 0.1, 0]; Position: [0.1, 0, 0.1, 0]; Text: \"Hello World!\"; } ]] , [ Children ] = { New 'TextLabel' { Text = 'Goodbye World!' , [ Toned . Ignore ] = { 'Text' } } } } Notice how in our style sheet we actually set the Text property of TextLabels to be Hello World! . When we create a child text label you would expect that Goodbye World! would override the style sheet's Text property. Unfortunately, this isn't the case. To work around this we use the Ignore key and set it to a table of values. In our case we only want one value, Text . Now we'll actually see Goodbye World! like intended. This is an unfortunate byproduct of Fusion's internal SpecialKey system not supporting a system like style sheets. While it can sometimes be tedious to set, the Ignore key is the best solution for this as of right now.","title":"Ignoring Properties"},{"location":"internals/","text":"Internals # If you're interested in learning more about how Toned works internally then this is for you. ToneLang # ToneLang is intricate and was designed with simplicity in mind. The original plan was to simply use string matching to create a \"language\" of sorts but this would be problematic and difficult to maintain. Tone needed to have longevity while being fairly easy to implement new features or extend the language. Therefore, an entire language pipeline was designed. The entirety of the language's internals can be found in src/ToneLang . Grammar # The first thought that goes into designing a language is its grammar. Tone was going to be a very small language and was not like traditional programming languages as it was intended for styling. It made sense to look towards CSS, the most popular style language. Heavy inspiration was taken from CSS in its design while still trying to maintain some semblance of a unique identity. The following is up-to-date grammar for Tone. You can also find Tone's grammar in src/ToneLang/Grammar.lua . program -> statement+ ; statement -> styleStatement | exprStatement ; styleStatement -> (simpleSelector | ancestrySelector)+ \"{\" propDeclaration* \"}\" ; exprStatement -> expression \";\" ; propDeclaration -> IDENTIFIER \":\" (unary | list | IDENTIFIER) \";\" ; expression -> assignment ; assignment -> \"var\" IDENTIFIER \":\" (unary | list) ; list -> \"[\" unary (\",\" unary)* \"]\" ; unary -> \"-\"? primary ; primary -> \"true\" | \"false\" | NUMBER | STRING | hexCode | enumeration ; hexCode -> \"#\" IDENTIFIER ; enumeration -> \"enum\" IDENTIFIER ; ancestrySelector -> simpleSelector \">\" (ancestrySelector | simpleSelector) ; simpleSelector -> classSelector | attrSelector | nameSelector ; classSelector -> \".\" IDENTIFIER ; nameSelector -> \"@\" (IDENTIFIER | captureClause) ; attrSelector -> \"%\" (IDENTIFIER | captureClause) ; captureClause -> \"(\" IDENTIFIER+ \")\" ; Lexer # Tone's Lexer is very simple and like any other traditional lexer. Characters get scanned and turned into tokens as expected. The list of tokens are then passed into the parser. The lexer can be found in src/ToneLang/Lexer.lua . Parser # Tone's Parser uses Recursive Descent (RD) to parse its input tokens. There's no need for backtracking and a program (or list of statements) is created by going top down like any other RD parser. The parser can be found in src/ToneLang/Parser.lua . Interpreter # Tone's Interpreter is interesting. Tone uses methods you'll find in other language interpreters (e.g. nodes with a vistation system) but we actually can't yet interpret every node. For example, if we have a literal node that contains a list (defined as a Lua table) we have no way of knowing what type to conform that list into yet. We need to create data in the interpreter that can be read by the special StyleSheet key used in Fusion. To do this each interpreter instance contains the following data: Parse Tree Variables Style Sheet The parse tree is, as expected, the tree created by our parser. We simply provide it to the interpreter and then the interpreter generates the other two crucical data points: the style sheet and variables. Since all variables in Toned are global to their unique style sheets we don't need to worry about scope or environments. This makes it easy as whenever the interpreter reaches a variable node we simply assign a string key (the name of the variable) as a key in the variables data table where the value is the value of the variable itself. Finally, we have the style sheet. This is the actual style sheet that is resolved by the StyleSheet special key in Fusion. This data point is simply a table of tables where each inner table contains an assignments and selectors table. The assignments table contains properties and their respective values to be set. The selectors table is an array of each selector token. The interpreter can be found in src/ToneLang/Interpreter.lua .","title":"Internals"},{"location":"internals/#internals","text":"If you're interested in learning more about how Toned works internally then this is for you.","title":"Internals"},{"location":"internals/#tonelang","text":"ToneLang is intricate and was designed with simplicity in mind. The original plan was to simply use string matching to create a \"language\" of sorts but this would be problematic and difficult to maintain. Tone needed to have longevity while being fairly easy to implement new features or extend the language. Therefore, an entire language pipeline was designed. The entirety of the language's internals can be found in src/ToneLang .","title":"ToneLang"},{"location":"internals/#grammar","text":"The first thought that goes into designing a language is its grammar. Tone was going to be a very small language and was not like traditional programming languages as it was intended for styling. It made sense to look towards CSS, the most popular style language. Heavy inspiration was taken from CSS in its design while still trying to maintain some semblance of a unique identity. The following is up-to-date grammar for Tone. You can also find Tone's grammar in src/ToneLang/Grammar.lua . program -> statement+ ; statement -> styleStatement | exprStatement ; styleStatement -> (simpleSelector | ancestrySelector)+ \"{\" propDeclaration* \"}\" ; exprStatement -> expression \";\" ; propDeclaration -> IDENTIFIER \":\" (unary | list | IDENTIFIER) \";\" ; expression -> assignment ; assignment -> \"var\" IDENTIFIER \":\" (unary | list) ; list -> \"[\" unary (\",\" unary)* \"]\" ; unary -> \"-\"? primary ; primary -> \"true\" | \"false\" | NUMBER | STRING | hexCode | enumeration ; hexCode -> \"#\" IDENTIFIER ; enumeration -> \"enum\" IDENTIFIER ; ancestrySelector -> simpleSelector \">\" (ancestrySelector | simpleSelector) ; simpleSelector -> classSelector | attrSelector | nameSelector ; classSelector -> \".\" IDENTIFIER ; nameSelector -> \"@\" (IDENTIFIER | captureClause) ; attrSelector -> \"%\" (IDENTIFIER | captureClause) ; captureClause -> \"(\" IDENTIFIER+ \")\" ;","title":"Grammar"},{"location":"internals/#lexer","text":"Tone's Lexer is very simple and like any other traditional lexer. Characters get scanned and turned into tokens as expected. The list of tokens are then passed into the parser. The lexer can be found in src/ToneLang/Lexer.lua .","title":"Lexer"},{"location":"internals/#parser","text":"Tone's Parser uses Recursive Descent (RD) to parse its input tokens. There's no need for backtracking and a program (or list of statements) is created by going top down like any other RD parser. The parser can be found in src/ToneLang/Parser.lua .","title":"Parser"},{"location":"internals/#interpreter","text":"Tone's Interpreter is interesting. Tone uses methods you'll find in other language interpreters (e.g. nodes with a vistation system) but we actually can't yet interpret every node. For example, if we have a literal node that contains a list (defined as a Lua table) we have no way of knowing what type to conform that list into yet. We need to create data in the interpreter that can be read by the special StyleSheet key used in Fusion. To do this each interpreter instance contains the following data: Parse Tree Variables Style Sheet The parse tree is, as expected, the tree created by our parser. We simply provide it to the interpreter and then the interpreter generates the other two crucical data points: the style sheet and variables. Since all variables in Toned are global to their unique style sheets we don't need to worry about scope or environments. This makes it easy as whenever the interpreter reaches a variable node we simply assign a string key (the name of the variable) as a key in the variables data table where the value is the value of the variable itself. Finally, we have the style sheet. This is the actual style sheet that is resolved by the StyleSheet special key in Fusion. This data point is simply a table of tables where each inner table contains an assignments and selectors table. The assignments table contains properties and their respective values to be set. The selectors table is an array of each selector token. The interpreter can be found in src/ToneLang/Interpreter.lua .","title":"Interpreter"},{"location":"stylesheets/","text":"Style Sheets # Style sheets are the main part of Toned. They allow you to define styles to apply to your UI. Let's create a basic style sheet. Creating Style Sheets # In reality, style sheets are just strings. Really, really, long strings. Unfortunately, Roblox doesn't support other file types besides .lua (which always translate into Script instances). This means to use a custom styling language we just use a string. It is best practice to have your style sheet be its own ModuleScript. Here's how one might look: return [[ // This is a style sheet! ]] Note In the rest of the documentation we won't include the return statement or the open & closing brackets for the string. Assume they are there anyways. To learn the language used by style sheets visit the language documentation . Applying Style Sheets # Toned comes equipped with a special key you can use in Fusion to apply your style sheets. local Toned = require ( ReplicatedStorage . Toned ) New 'ScreenGui' { [ Toned . StyleSheet ] = require ( script . Parent . SomeStyleSheet ) } Style sheets are applied to all descendants of the instance they are applied to. If a descendant is added to the root instance then the style sheet after it has initially been applied then it will also apply itself to that new descendant. Here is a better example of this: local myLabels = Value ({ 'Hello!' }) New 'ScreenGui' { [ Toned . StyleSheet ] = [[ .TextLabel { BackgroundColor3: #212121; TextColor3: #FFFFFF; TextXAlignment: enum Center; Size: [0.05, 0, 0.05, 0]; } ]] , [ Children ] = ForPairs ( myLabels , function ( key : number , value : string ) return key , New 'TextLabel' { Text = value , Position = UDim2 . new ( key * 0.05 , 0 , 0.05 , 0 ), } end , Fusion . cleanup ) } task . wait ( 5 ) myLabels : set ({ 'These' , 'labels' , 'are' , 'styled!' }) When the myLabels value changes the new labels created all have their respective styles applied from the style sheet.","title":"StyleSheet"},{"location":"stylesheets/#style-sheets","text":"Style sheets are the main part of Toned. They allow you to define styles to apply to your UI. Let's create a basic style sheet.","title":"Style Sheets"},{"location":"stylesheets/#creating-style-sheets","text":"In reality, style sheets are just strings. Really, really, long strings. Unfortunately, Roblox doesn't support other file types besides .lua (which always translate into Script instances). This means to use a custom styling language we just use a string. It is best practice to have your style sheet be its own ModuleScript. Here's how one might look: return [[ // This is a style sheet! ]] Note In the rest of the documentation we won't include the return statement or the open & closing brackets for the string. Assume they are there anyways. To learn the language used by style sheets visit the language documentation .","title":"Creating Style Sheets"},{"location":"stylesheets/#applying-style-sheets","text":"Toned comes equipped with a special key you can use in Fusion to apply your style sheets. local Toned = require ( ReplicatedStorage . Toned ) New 'ScreenGui' { [ Toned . StyleSheet ] = require ( script . Parent . SomeStyleSheet ) } Style sheets are applied to all descendants of the instance they are applied to. If a descendant is added to the root instance then the style sheet after it has initially been applied then it will also apply itself to that new descendant. Here is a better example of this: local myLabels = Value ({ 'Hello!' }) New 'ScreenGui' { [ Toned . StyleSheet ] = [[ .TextLabel { BackgroundColor3: #212121; TextColor3: #FFFFFF; TextXAlignment: enum Center; Size: [0.05, 0, 0.05, 0]; } ]] , [ Children ] = ForPairs ( myLabels , function ( key : number , value : string ) return key , New 'TextLabel' { Text = value , Position = UDim2 . new ( key * 0.05 , 0 , 0.05 , 0 ), } end , Fusion . cleanup ) } task . wait ( 5 ) myLabels : set ({ 'These' , 'labels' , 'are' , 'styled!' }) When the myLabels value changes the new labels created all have their respective styles applied from the style sheet.","title":"Applying Style Sheets"},{"location":"tonelang/","text":"ToneLang # The language Toned uses is called Tone (or ToneLang). It's a custom style language created specifically for this module. It was designed to be similar to CSS so if you've ever dabbled in web design, Tone should be fairly easy to pick up. Comments # In your style sheet you can create comments using -- or // . -- This is a comment // This is also a comment Note Tone only supports single-line comments. Literals # Tone supports basic literals similar to Lua. The language itself is dynamically typed. The following is a list of valid literals: Booleans ( true , false ) Strings ( \"This is a string\" ) Numbers ( 123 ) Hex Codes ( #FFFFFF ) Enums ( enum Left -- more on enums below) Lists ( [\"This is\", \"my\", \"list\"] -- more on lists below) Variables # You can define variables in Tone using the var keyword. var myVariable: 5; Note Variables must be set to a literal (e.g. a string, number, hex code, etc.) Identifiers such as other variables are not valid literals and cannot be used to define a variable (e.g. var myVariable: someOtherVariable; is not valid). Selectors # When writing styles to style the various parts of your UI you need to somehow select the instances you want to style. This is where selectors come into play. Toned currently offers 3 simple selectors for instance classes, instance names, and a special attribute selector. If you want to select an instance that has a certain class you use the . token. .TextButton { } If you want to select an instance that has a certain name you use the @ token. @MyLabel { } If you want to select an instance through the special attribute selector you use the % token. %MyAttribute { } Both name and attribute selectors offer a way to select an instance that has a multi-worded name or attribute (e.g. My Label -- notice the space). To do so you can use a capture clause which is defined by parentheses: @(My Label) { } You can also combine selectors to apply a style to multiple selections. .TextButton @MyLabel { } // This is completely valid Ancestry Selector # Sometimes you might only want to select an instance that has a particular ancestry. For example, a TextLabel within a Frame within another Frame called MyFrame . Toned allows you to do this with ease. The syntax uses the > token to express ancestry. @MyFrame > .Frame > .TextLabel { Text: \"Hello World!\"; } The style statement gets applied to the inner most element, in this case a TextLabel. Toned doesn't limit your selector capacity when using ancestry selectors. What this means is the above is considered only one single selector. You can continue using other selectors as you normally would. The syntax for having multiple selectors alongside an ancestry selector can sometimes get a little messy and therefore it is best practice to separate each selector onto its own line to maintain legibility. .TextButton @MyFrame > .Frame > .TextLabel { Text: \"Hello World!\"; } The above applies the style statement to all TextButtons as well as all TextLabels within a Frame within another Frame named MyFrame . Style Statements # In the above selectors you might have noticed the curly braces following each selector. This is necessary as it tells Tone to expect a style statement. A style statement is how you style your various instances. Within the curly braces you can include various property declarations that tell Tone what value to assign a certain property of an instance. The following is an example of a complete style statement: .TextLabel { Text: \"Hello World!\"; // This line is called a property declaration } Each expression within a style statement's curly braces ending with a semicolon is considered a property declaration. On the left of the colon you write out the name of the property you are setting and on the right you define its value. You can use variables or literals as valid values. Here is a more extensive example using a variable and literals. var colorWhite: #FFFFFF; .TextLabel @(My Text Label) { TextColor3: colorWhite; Text: \"This is my label!\"; Size: [0.1, 0, 0.1, 0]; } Lists # Lists are arrays of values. They are defined with an open bracket with each element inside a list being separated by a comma. Lists cannot be defined empty (e.g. [] is an invalid list) and at least one element must be present. The interesting thing about lists is that they are dynamic. They will conform to whatever the type of the property they are being set is. This means they can be used anywhere for values that aren't a valid literal. .TextLabel { TextColor3: [125, 50, 180]; Position: [0.5, 0, 0.5, 0]; Size: [0, 30, 0, 30]; } In the above example, TextColor3 expects a Roblox Color3 type. However, Tone doesn't support Color3 and therefore you can just pass in a list. The same applies for the Position and Size properties. When your style sheet is applied all lists will dynamically conform to their expected type. In the case of TextColor3 , each value in the list represents red, green, and blue in a Color3 respectively. Note Lists transform into Color3 types using Color3.fromRGB() not Color.new() . Therefore each value in a list should be between 0-255. Enums # Similar to lists, enums will conform to their property. The following is entirely valid: .TextLabel { TextXAlignment: enum Left; } .UIListLayout { SortOrder: enum LayoutOrder; } The property TextXAlignment will be set to Enum.TextXAlignment.Left . The property SortOrder will be set to Enum.SortOrder.LayoutOrder . Tone allows you to entirely skip writing out the enum group and get directly to the item itself.","title":"Tone Language"},{"location":"tonelang/#tonelang","text":"The language Toned uses is called Tone (or ToneLang). It's a custom style language created specifically for this module. It was designed to be similar to CSS so if you've ever dabbled in web design, Tone should be fairly easy to pick up.","title":"ToneLang"},{"location":"tonelang/#comments","text":"In your style sheet you can create comments using -- or // . -- This is a comment // This is also a comment Note Tone only supports single-line comments.","title":"Comments"},{"location":"tonelang/#literals","text":"Tone supports basic literals similar to Lua. The language itself is dynamically typed. The following is a list of valid literals: Booleans ( true , false ) Strings ( \"This is a string\" ) Numbers ( 123 ) Hex Codes ( #FFFFFF ) Enums ( enum Left -- more on enums below) Lists ( [\"This is\", \"my\", \"list\"] -- more on lists below)","title":"Literals"},{"location":"tonelang/#variables","text":"You can define variables in Tone using the var keyword. var myVariable: 5; Note Variables must be set to a literal (e.g. a string, number, hex code, etc.) Identifiers such as other variables are not valid literals and cannot be used to define a variable (e.g. var myVariable: someOtherVariable; is not valid).","title":"Variables"},{"location":"tonelang/#selectors","text":"When writing styles to style the various parts of your UI you need to somehow select the instances you want to style. This is where selectors come into play. Toned currently offers 3 simple selectors for instance classes, instance names, and a special attribute selector. If you want to select an instance that has a certain class you use the . token. .TextButton { } If you want to select an instance that has a certain name you use the @ token. @MyLabel { } If you want to select an instance through the special attribute selector you use the % token. %MyAttribute { } Both name and attribute selectors offer a way to select an instance that has a multi-worded name or attribute (e.g. My Label -- notice the space). To do so you can use a capture clause which is defined by parentheses: @(My Label) { } You can also combine selectors to apply a style to multiple selections. .TextButton @MyLabel { } // This is completely valid","title":"Selectors"},{"location":"tonelang/#ancestry-selector","text":"Sometimes you might only want to select an instance that has a particular ancestry. For example, a TextLabel within a Frame within another Frame called MyFrame . Toned allows you to do this with ease. The syntax uses the > token to express ancestry. @MyFrame > .Frame > .TextLabel { Text: \"Hello World!\"; } The style statement gets applied to the inner most element, in this case a TextLabel. Toned doesn't limit your selector capacity when using ancestry selectors. What this means is the above is considered only one single selector. You can continue using other selectors as you normally would. The syntax for having multiple selectors alongside an ancestry selector can sometimes get a little messy and therefore it is best practice to separate each selector onto its own line to maintain legibility. .TextButton @MyFrame > .Frame > .TextLabel { Text: \"Hello World!\"; } The above applies the style statement to all TextButtons as well as all TextLabels within a Frame within another Frame named MyFrame .","title":"Ancestry Selector"},{"location":"tonelang/#style-statements","text":"In the above selectors you might have noticed the curly braces following each selector. This is necessary as it tells Tone to expect a style statement. A style statement is how you style your various instances. Within the curly braces you can include various property declarations that tell Tone what value to assign a certain property of an instance. The following is an example of a complete style statement: .TextLabel { Text: \"Hello World!\"; // This line is called a property declaration } Each expression within a style statement's curly braces ending with a semicolon is considered a property declaration. On the left of the colon you write out the name of the property you are setting and on the right you define its value. You can use variables or literals as valid values. Here is a more extensive example using a variable and literals. var colorWhite: #FFFFFF; .TextLabel @(My Text Label) { TextColor3: colorWhite; Text: \"This is my label!\"; Size: [0.1, 0, 0.1, 0]; }","title":"Style Statements"},{"location":"tonelang/#lists","text":"Lists are arrays of values. They are defined with an open bracket with each element inside a list being separated by a comma. Lists cannot be defined empty (e.g. [] is an invalid list) and at least one element must be present. The interesting thing about lists is that they are dynamic. They will conform to whatever the type of the property they are being set is. This means they can be used anywhere for values that aren't a valid literal. .TextLabel { TextColor3: [125, 50, 180]; Position: [0.5, 0, 0.5, 0]; Size: [0, 30, 0, 30]; } In the above example, TextColor3 expects a Roblox Color3 type. However, Tone doesn't support Color3 and therefore you can just pass in a list. The same applies for the Position and Size properties. When your style sheet is applied all lists will dynamically conform to their expected type. In the case of TextColor3 , each value in the list represents red, green, and blue in a Color3 respectively. Note Lists transform into Color3 types using Color3.fromRGB() not Color.new() . Therefore each value in a list should be between 0-255.","title":"Lists"},{"location":"tonelang/#enums","text":"Similar to lists, enums will conform to their property. The following is entirely valid: .TextLabel { TextXAlignment: enum Left; } .UIListLayout { SortOrder: enum LayoutOrder; } The property TextXAlignment will be set to Enum.TextXAlignment.Left . The property SortOrder will be set to Enum.SortOrder.LayoutOrder . Tone allows you to entirely skip writing out the enum group and get directly to the item itself.","title":"Enums"}]}